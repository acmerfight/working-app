# Working App 项目规范

## 语言
- 始终使用中文回复

## 开发模式：BDD (Behavior-Driven Development)

### 开发流程
1. **需求分析** → 理解用户故事
2. **设计 BDD Case** → 先写 Given/When/Then 场景
3. **编写测试** → 根据 BDD Case 编写测试代码
4. **实现功能** → 让测试通过
5. **重构** → 优化代码

### BDD Case 格式
```gherkin
Feature: [功能名称]
  As a [角色]
  I want [目标]
  So that [收益]

  Scenario: [场景名称]
    Given [前置条件]
    When [触发动作]
    Then [期望结果]
```

### 示例
```gherkin
Feature: 计数器
  As a 用户
  I want 增减计数
  So that 可以跟踪数量

  Scenario: 增加计数
    Given 当前计数为 0
    When 用户点击 "+1" 按钮
    Then 计数应该变为 1

  Scenario: 减少计数
    Given 当前计数为 5
    When 用户点击 "-1" 按钮
    Then 计数应该变为 4
```

## 架构规范：React 渲染 + Jotai 状态

### 核心原则
- **React 只负责 UI 渲染**
- **Jotai 负责所有状态管理和业务逻辑**
- **严格分离关注点**

### 禁止使用的 React Hooks
```typescript
// ❌ 禁止
useState      // 使用 atom 替代
useReducer    // 使用 atom 替代
useCallback   // 使用 action atoms + useSetAtom 替代
useMemo       // 使用派生 atom 替代
useEffect     // 使用 atomEffect 或 onMount 替代
useRef        // 仅 DOM 引用可用，状态相关禁止
useContext    // 使用 Provider + atom 替代
```

### 允许使用的 Jotai Hooks
```typescript
// ✅ 允许
useAtom       // 读写 atom
useAtomValue  // 只读 atom
useSetAtom    // 只写 atom（用于 action atoms）
```

### Atom 分类

#### 1. State Atoms（状态原子）
```typescript
// 基础状态
export const countAtom = atom(0);
export const userAtom = atom<User | null>(null);
```

#### 2. Derived Atoms（派生原子）
```typescript
// 替代 useMemo
export const doubleCountAtom = atom((get) => get(countAtom) * 2);
export const isLoggedInAtom = atom((get) => get(userAtom) !== null);
```

#### 3. Action Atoms（行为原子）
```typescript
// 替代 useCallback
export const incrementAtom = atom(null, (get, set) => {
  set(countAtom, get(countAtom) + 1);
});

// 异步 action
export const fetchUserAtom = atom(null, async (get, set) => {
  set(loadingAtom, true);
  try {
    const user = await api.getUser();
    set(userAtom, user);
  } finally {
    set(loadingAtom, false);
  }
});
```

#### 4. Effect Atoms（副作用原子）
```typescript
// 替代 useEffect
import { atomEffect } from 'jotai-effect';

export const logCountEffect = atomEffect((get) => {
  console.log('Count changed:', get(countAtom));
});
```

### 组件结构模板
```typescript
import { useAtomValue, useSetAtom } from "jotai";
import { 
  dataAtom, 
  loadingAtom,
  actionAtom 
} from "../store";

export function MyComponent() {
  // 只读状态
  const data = useAtomValue(dataAtom);
  const isLoading = useAtomValue(loadingAtom);
  
  // Action（稳定引用，无需 useCallback）
  const doAction = useSetAtom(actionAtom);

  // 纯渲染，无业务逻辑
  return (
    <div>
      {isLoading ? <Spinner /> : <Content data={data} />}
      <button onClick={doAction}>执行</button>
    </div>
  );
}
```

## 文件结构

```
src/
├── components/        # React 组件（纯渲染）
├── store/
│   ├── atoms/        # 所有 atoms 定义
│   │   ├── index.ts  # 导出所有 atoms
│   │   ├── user.ts   # 用户相关 atoms
│   │   └── ui.ts     # UI 状态 atoms
│   └── index.ts      # Store 配置
├── lib/              # 工具函数、API 客户端
└── test/             # 测试配置
```

## 测试规范

### 单元测试
- 使用 Vitest
- Atoms 应独立测试
- 组件测试使用 Testing Library

### 测试文件命名
```
ComponentName.test.tsx    # 组件测试
atomName.test.ts         # Atom 测试
```

## 技术栈
- React 19 + TypeScript
- Jotai（状态管理）
- Hono（后端 API）
- Vite（构建工具）
- Vitest（测试）
- pnpm（包管理）

